# -*- coding: utf-8 -*-
"""
Created on Thu Jul  7 12:18:30 2024
adding text at 12:43 EST
@author: prave
"""

from ib_insync import *
import nest_asyncio
import datetime
import pandas as pd
from discord import SyncWebhook
import requests
from datetime import timedelta
import json, time
nest_asyncio.apply()

# reading text file 
cred_file = pd.read_csv('next_gen_v2_cred_text.txt', header=None)
webhook_link = cred_file.iloc[0][0].split('=')[1].strip()
discordChLink = cred_file.iloc[1][0].split('=')[1].strip()
authCode = cred_file.iloc[2][0].split('=')[1].strip()
portNum = cred_file.iloc[3][0].split('=')[1].strip()
# qty = cred_file.iloc[4][0].split('=')[1].strip()
contractName = cred_file.iloc[5][0].split('=')[1].strip()

# read discord messages 
# TTB channel
webhook = SyncWebhook.from_url(webhook_link)
discordChannel = discordChLink
authorizationCode = authCode

def retrieve_messages():
    headers = {
        'authorization': authorizationCode
    }

    r = requests.get(discordChannel, headers=headers)

    jobj = json.loads(r.text)
    i = 0
    df = pd.DataFrame()
    for value in jobj:
        i += 1
        if i > 2:
            break
        df = pd.concat([df, pd.DataFrame([value['content'], value['timestamp']]).transpose()])

    return df

def send_discord_message(message):
    webhook.send(message)

# Connect to IB TWS or Gateway
# util.startLoop()
clientId = 1
def connect_with_retry(host, port, max_retries, clientId):
    connected = False
    ib = IB()

    while not connected and clientId <= max_retries:
        try:
            print(f'Trying to connect with clientId = {clientId}')
            ib.connect(host, port, clientId=clientId)
            time.sleep(2)
            ib.accountSummary()
            connected = True
            
            account_summary = ib.accountSummary()
            available_funds = None
            TotalCashValue = None
            for item in account_summary:
                if item.tag == 'ExcessLiquidity':
                    available_funds = item.value
                
                if item.tag == 'TotalCashValue':
                    TotalCashValue  = item.value 
                    
            print(f'Successfully connected with clientId = {clientId}, available funds = {available_funds}, total cash value = {TotalCashValue}')
        except Exception as e:
            print(type(e))
            e1 = e
            print(f'Connection failed with clientId = {clientId}. Retrying...')
            if "name 'host' is not defined" in str(e1):
                send_discord_message('Login to the IB Account.')
                break
            clientId += 1
            time.sleep(1)  # Sleep for a short while before retrying

    if not connected:
        raise ConnectionError(f'Unable to connect to IB TWS/Gateway after {max_retries} attempts.')

    return ib, clientId

ib, clientId = connect_with_retry('127.0.0.1', portNum, 10, clientId)

# getting account balance 
account_summary = ib.accountSummary()
available_funds = None
for item in account_summary:
    if item.tag == 'ExcessLiquidity':
        available_funds = item.value
        break
    
available_funds = float(available_funds)
textdiscord = "Connection established with ClientID"+str(clientId)+" with $" + str(available_funds)
send_discord_message(textdiscord)

# estimate position size for this account 
cnt = Future(symbol = 'ES', lastTradeDateOrContractMonth="", exchange="CME")
details = ib.reqContractDetails(cnt)
total_details = len(details)
crntexp = []
for i in range(total_details):
    crntexp.append(details[i].contract.lastTradeDateOrContractMonth)

dates_datetime = [datetime.datetime.strptime(date, '%Y%m%d') for date in crntexp]
latest_date_2 = pd.to_datetime(dates_datetime).sort_values()[0].strftime('%Y-%m-%d')
latest_date = pd.to_datetime(dates_datetime).sort_values()[0].strftime('%Y%m%d')
latest_exp_month = latest_date[:-2]
    
specific_date = datetime.datetime.strptime(latest_date, '%Y%m%d')

# Get the current date
current_date = datetime.datetime.now()
difference = specific_date - current_date
days_difference = difference.days

if days_difference < 7:     
    nextexp = specific_date + timedelta(days = 90)
    latest_exp_month = nextexp.strftime('%Y%m')

# Define contract details for ES (E-mini S&P 500)
contract = Future(symbol = contractName, lastTradeDateOrContractMonth = latest_exp_month, exchange = "CME")

# position sizing
qty = None 

import math 
if contractName == "MES":
    qty = math.floor(available_funds/1500)
elif contractName == "ES":
    qty = math.floor(available_funds/15000)

if qty == 0:
    send_discord_message('0 QTY, fix the issue!')
else:
    send_discord_message('Qty detected by logic: '+str(qty))

def bktOrderFunc(side, qty, limit_price, take_profit_price, stop_loss_price):
    limit_price = limit_price
    take_profit_price = take_profit_price  # take profit price
    stop_loss_price = stop_loss_price  # stop loss price

    # Create bracket order
    take_profit_order = LimitOrder('SELL' if side == 'BUY' else "BUY", qty, take_profit_price, tif='GTC')
    stop_loss_order = StopOrder('SELL' if side == 'BUY' else "BUY", qty, stop_loss_price, tif='GTC')

    # Create a list to hold all bracket orders
    bracket_order = ib.bracketOrder(
            action = 'BUY' if side == 'BUY' else "SELL",
            quantity =  qty,
            limitPrice = limit_price, 
            takeProfitPrice = take_profit_price,
            stopLossPrice =  stop_loss_price)

    for o in bracket_order:
        o.outsideRth = True
        o.tif = "GTC"
        
    # Iterate over each order in the bracket and place it
    for o in bracket_order:
         ib.placeOrder(contract, o)

# Function to check if there are active bracket orders
def has_active_bracket_orders():
    open_orders = ib.openOrders()
    for order in open_orders:
        if order.parentId:  # Check if the order has a parent ID (indicating it's part of a bracket order)
            return True
    return False

# Function to refresh the connection
def refresh_connection():
    global ib, clientId
    ib.disconnect()
    time.sleep(1)
    ib, clientId = connect_with_retry('127.0.0.1', portNum, 100, clientId)
    send_discord_message('Connection refreshed.')

# Function to check open positions
def check_open_positions():
    positions = ib.positions()
    if positions:
        positions_info = '\n'.join([f'Contract: {position.contract.symbol}, Position: {position.position}' for position in positions])
    else:
        positions_info = 'No open positions.'
    send_discord_message(f'Open Positions:\n{positions_info}')

# Function to check open orders
def check_open_orders():
    open_orders = ib.openOrders()
    if open_orders:
        orders_info = '\n'.join([f'Order ID: {order.orderId}, Action: {order.action}, Quantity: {order.totalQuantity}, Status: {order.status}' for order in open_orders])
    else:
        orders_info = 'No open orders.'
    send_discord_message(f'Open Orders:\n{orders_info}')

import pytz 
newYorkTz = pytz.timezone("US/Eastern")
UtcTz = pytz.timezone("UTC")
timeInNewYork = datetime.datetime.now(newYorkTz)

# Core logic
crntmsg = '1'
prevmsg = '2'

import datetime
from datetime import timedelta
exitTime = datetime.datetime.now() + timedelta(minutes=29, seconds=50)
print('exitTime is ', exitTime)
while crntmsg != prevmsg:
    try:
        crnthour = timeInNewYork.hour
        prevhour = crnthour
        crntmin = timeInNewYork.minute
        prevmin = crntmin
        msg = retrieve_messages()
        crntmsg = msg.iloc[0][0]
        prevmsg = crntmsg
        print(crntmsg)

        # Check for specific commands
        if 'refresh connection' in crntmsg.lower():
            refresh_connection()
        elif 'open positions' in crntmsg.lower():
            check_open_positions()
        elif 'open orders' in crntmsg.lower():
            check_open_orders()
        
    except:
        time.sleep(.5)
